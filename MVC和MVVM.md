<<<<<<< HEAD
## MVC  
MVC是一个架构，或者说是一个设计模式，它就是强制性使应用程序的输入，处理和输出分开。将一个应用程序分为三个部分：Model，View，Controller。 MVC虽然是三个部分，但是注意，它不是三层，跟三层也没有关系。如果非要分类的话，它属于框架模式。  

## 分析：  

Model 模型（完成业务逻辑：由javaBean构成，在MVC的三个部件中，模型拥有最多的处理任务。例如它可能用象EJBs和javabean这样的构件对象来处理数据库。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。）  
View 视图（就是负责跟用户交互的界面。一般就是由HTML，css元素组成的界面，当然现在还有一些像js，ajax，flex一些也都属于视图层。 在视图层里没有真正的处理发生，之负责数据输出，并允许用户操纵的方式。MVC能为应用程序处理很多不同的视图。 ）  
Controller 控制器（接收请求—>调用模型—>根据结果派发页面并经过模型处理返回相应数据 ） 

--------------------------------------------------------------------------  

## 优点：
1、分工明确（开发人员可以只关注整个结构中的其中某一层）：使用MVC可以把数据库开发，程序业务逻辑开发，页面开发分开，每一层都具有相同的特征，方便以后的代码维护。  
它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。    
2、松耦合（可以降低层与层之间的依赖）：视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。  
因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。   
3、复用性高（利于各层逻辑的复用）：像多个视图能够共享一个模型，不论你视图层是用flash界面或是wap界面，用一个模型就能处理他们。将数据和业务规则从表示层分开，就可以最大化从用代码。  

3、有利于标准化（有利于通过工程化、工具化产生管理程序代码）；  

概括来说，分层式设计可以达至如下目的：分散关注、松散耦合、逻辑复用、标准定义。  

## 缺点:    
分层式结构也不可避免具有一些缺陷：  
1、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。  
2、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。  
3、由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。  
4、MVC并不适合小型甚至中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。   

## 如何改善：  
第一个缺点，可以采用一些设计模式来到改善。  
第二个缺点，可以通过系统的缓存机制来减小对性能的影响；  

## MVVM定义  
MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。  
【模型】指的是后端传递的数据。  
【视图】指的是所看到的页面。  
【视图模型】MVVM模式的核心，它是连接view和model的桥梁。它有两个方向：  
一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。  
二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。  
这两个方向都实现的，我们称之为数据的双向绑定。  
总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。  

## MVVM框架:VUE的介绍  
Vue就是基于MVVM模式实现的一套框架，在vue中：Model:指的是js中的数据，如对象，数组等等。View:指的是页面视图  
viewModel:指的是vue实例化对象。  
为什么说VUE是一个渐进式的javascript框架, 渐进式是什么意思？  
1.如果你已经有一个现成的服务端应用，你可以将vue 作为该应用的一部分嵌入其中，带来更加丰富的交互体验;  
2.如果你希望将更多业务逻辑放到前端来实现，那么VUE的核心库及其生态系统也可以满足你的各式需求（core+vuex+vue-route）。和其它前端框架一样，VUE允许你将一个网页分割成可复用的组件，每个组件都包含属于自己的HTML、CSS、JAVASCRIPT以用来渲染网页中相应的地方。  
3.如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成为各自的组件和文件，vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单（vue init webpack my-project）。我们可以使用VUE的单文件组件，它包含了各自的HTML、JAVASCRIPT以及带作用域的CSS或SCSS。以上这三个例子，是一步步递进的，也就是说对VUE的使用可大可小，它都会有相应的方式来整合到你的项目中。  
所以说它是一个渐进式的框架。VUE最独特的特性：响应式系统VUE是响应式的（reactive），也就是说当我们的数据变更时，VUE会帮你更新所有网页中用到它的地方。  
关于这个响应式原理，官方已经讲得很清楚，不懂的同学，可以https://cn.vuejs.org/v2/guide/reactivity.html 查看。  

## 我们讲一下主流框架实现双向绑定（响应式）的做法：  

1. 脏值检查：angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。  

2.观察者-订阅者（数据劫持）：vueObserver 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。  

=======
## MVC  
MVC是一个架构，或者说是一个设计模式，它就是强制性使应用程序的输入，处理和输出分开。将一个应用程序分为三个部分：Model，View，Controller。 MVC虽然是三个部分，但是注意，它不是三层，跟三层也没有关系。如果非要分类的话，它属于框架模式。  

## 分析：  

Model 模型（完成业务逻辑：由javaBean构成，在MVC的三个部件中，模型拥有最多的处理任务。例如它可能用象EJBs和javabean这样的构件对象来处理数据库。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。）  
View 视图（就是负责跟用户交互的界面。一般就是由HTML，css元素组成的界面，当然现在还有一些像js，ajax，flex一些也都属于视图层。 在视图层里没有真正的处理发生，之负责数据输出，并允许用户操纵的方式。MVC能为应用程序处理很多不同的视图。 ）  
Controller 控制器（接收请求—>调用模型—>根据结果派发页面并经过模型处理返回相应数据 ） 

--------------------------------------------------------------------------  

## 优点：
1、分工明确（开发人员可以只关注整个结构中的其中某一层）：使用MVC可以把数据库开发，程序业务逻辑开发，页面开发分开，每一层都具有相同的特征，方便以后的代码维护。  
它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。    
2、松耦合（可以降低层与层之间的依赖）：视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。  
因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。   
3、复用性高（利于各层逻辑的复用）：像多个视图能够共享一个模型，不论你视图层是用flash界面或是wap界面，用一个模型就能处理他们。将数据和业务规则从表示层分开，就可以最大化从用代码。  

3、有利于标准化（有利于通过工程化、工具化产生管理程序代码）；  

概括来说，分层式设计可以达至如下目的：分散关注、松散耦合、逻辑复用、标准定义。  

## 缺点:    
分层式结构也不可避免具有一些缺陷：  
1、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。  
2、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。  
3、由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。  
4、MVC并不适合小型甚至中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。   

## 如何改善：  
第一个缺点，可以采用一些设计模式来到改善。  
第二个缺点，可以通过系统的缓存机制来减小对性能的影响；  

## MVVM定义  
MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。  
【模型】指的是后端传递的数据。  
【视图】指的是所看到的页面。  
【视图模型】MVVM模式的核心，它是连接view和model的桥梁。它有两个方向：  
一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。  
二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。  
这两个方向都实现的，我们称之为数据的双向绑定。  
总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。  

## MVVM框架:VUE的介绍  
Vue就是基于MVVM模式实现的一套框架，在vue中：Model:指的是js中的数据，如对象，数组等等。View:指的是页面视图  
viewModel:指的是vue实例化对象。  
为什么说VUE是一个渐进式的javascript框架, 渐进式是什么意思？  
1.如果你已经有一个现成的服务端应用，你可以将vue 作为该应用的一部分嵌入其中，带来更加丰富的交互体验;  
2.如果你希望将更多业务逻辑放到前端来实现，那么VUE的核心库及其生态系统也可以满足你的各式需求（core+vuex+vue-route）。和其它前端框架一样，VUE允许你将一个网页分割成可复用的组件，每个组件都包含属于自己的HTML、CSS、JAVASCRIPT以用来渲染网页中相应的地方。  
3.如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成为各自的组件和文件，vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单（vue init webpack my-project）。我们可以使用VUE的单文件组件，它包含了各自的HTML、JAVASCRIPT以及带作用域的CSS或SCSS。以上这三个例子，是一步步递进的，也就是说对VUE的使用可大可小，它都会有相应的方式来整合到你的项目中。  
所以说它是一个渐进式的框架。VUE最独特的特性：响应式系统VUE是响应式的（reactive），也就是说当我们的数据变更时，VUE会帮你更新所有网页中用到它的地方。  
关于这个响应式原理，官方已经讲得很清楚，不懂的同学，可以https://cn.vuejs.org/v2/guide/reactivity.html 查看。  

## 我们讲一下主流框架实现双向绑定（响应式）的做法：  

1. 脏值检查：angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。  

2.观察者-订阅者（数据劫持）：vueObserver 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。  

>>>>>>> 42c5be18811d562560a12d4913cd9cf6405d3620
当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。好了，关于mvvm设计模式及vue的双向绑定原理就讲到这。说实话，写这篇文章很费脑子，我们也参考了很多人的文章，可以说是总结的一个大杂烩。最近这两年Vue太火了，不懂VUE都不好意思说自己是干前端的，程序思维现在正着力把之前写的项目改造成vue的方式。  